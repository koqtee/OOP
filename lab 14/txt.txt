#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <stdexcept>

class Long {
private:
    std::vector<unsigned char> digits; // цифры числа 
    bool sign; // true для отрицательных, false для положительных

    // Вспомогательные методы
    void removeLeadingZeros();
    void normalize();
    int compareAbsolute(const Long& other) const;
    Long addAbsolute(const Long& other) const;
    Long subtractAbsolute(const Long& other) const;

public:
    // Конструкторы
    Long();
    Long(long long num);
    Long(const std::string& str);
    Long(const Long& other) = default;

    // Операторы присваивания
    Long& operator=(const Long& other) = default;
    Long& operator=(long long num);

    // Арифметические операторы
    Long operator+(const Long& other) const;
    Long operator-(const Long& other) const;
    Long operator*(const Long& other) const;
    Long operator/(const Long& other) const;
    Long operator%(const Long& other) const;

    // Унарные операторы
    Long operator-() const;
    Long operator+() const;

    // Составные операторы присваивания
    Long& operator+=(const Long& other);
    Long& operator-=(const Long& other);
    Long& operator*=(const Long& other);
    Long& operator/=(const Long& other);
    Long& operator%=(const Long& other);

    // Операторы инкремента и декремента
    Long& operator++();    // префиксный
    Long operator++(int);  // постфиксный
    Long& operator--();    // префиксный
    Long operator--(int);  // постфиксный

    // Операторы сравнения
    bool operator==(const Long& other) const;
    bool operator!=(const Long& other) const;
    bool operator<(const Long& other) const;
    bool operator<=(const Long& other) const;
    bool operator>(const Long& other) const;
    bool operator>=(const Long& other) const;

    // Ввод/вывод
    friend std::ostream& operator<<(std::ostream& os, const Long& num);
    friend std::istream& operator>>(std::istream& is, Long& num);

    // Вспомогательные методы
    std::string toString() const;
    bool isZero() const;
    Long abs() const;
};

// Реализация методов

void Long::removeLeadingZeros() {
    while (digits.size() > 1 && digits.back() == 0) {
        digits.pop_back();
    }
    if (digits.size() == 1 && digits[0] == 0) {
        sign = false; // ноль всегда положительный
    }
}

void Long::normalize() {
    removeLeadingZeros();
}

int Long::compareAbsolute(const Long& other) const {
    if (digits.size() != other.digits.size()) {
        return digits.size() < other.digits.size() ? -1 : 1;
    }

    for (int i = digits.size() - 1; i >= 0; --i) {
        if (digits[i] != other.digits[i]) {
            return digits[i] < other.digits[i] ? -1 : 1;
        }
    }
    return 0;
}

Long Long::addAbsolute(const Long& other) const {
    Long result;
    result.digits.clear();

    size_t maxSize = std::max(digits.size(), other.digits.size());
    int carry = 0;

    for (size_t i = 0; i < maxSize || carry; ++i) {
        int sum = carry;
        if (i < digits.size()) sum += digits[i];
        if (i < other.digits.size()) sum += other.digits[i];

        result.digits.push_back(sum % 10);
        carry = sum / 10;
    }

    result.normalize();
    return result;
}

Long Long::subtractAbsolute(const Long& other) const {
    Long result;
    result.digits.clear();

    int borrow = 0;
    for (size_t i = 0; i < digits.size(); ++i) {
        int diff = digits[i] - borrow;
        if (i < other.digits.size()) {
            diff -= other.digits[i];
        }

        if (diff < 0) {
            diff += 10;
            borrow = 1;
        }
        else {
            borrow = 0;
        }

        result.digits.push_back(diff);
    }

    result.normalize();
    return result;
}

// Конструкторы
Long::Long() : sign(false) {
    digits.push_back(0);
}

Long::Long(long long num) {
    if (num == 0) {
        digits.push_back(0);
        sign = false;
        return;
    }

    sign = num < 0;
    unsigned long long absNum = std::abs(num);

    digits.clear();
    while (absNum > 0) {
        digits.push_back(absNum % 10);
        absNum /= 10;
    }
}

Long::Long(const std::string& str) {
    if (str.empty()) {
        digits.push_back(0);
        sign = false;
        return;
    }

    size_t start = 0;
    if (str[0] == '-') {
        sign = true;
        start = 1;
    }
    else if (str[0] == '+') {
        sign = false;
        start = 1;
    }
    else {
        sign = false;
    }

    digits.clear();
    for (int i = str.length() - 1; i >= static_cast<int>(start); --i) {
        if (str[i] >= '0' && str[i] <= '9') {
            digits.push_back(str[i] - '0');
        }
        else {
            throw std::invalid_argument("Invalid character in number string");
        }
    }

    normalize();
    if (isZero()) sign = false;
}

Long& Long::operator=(long long num) {
    *this = Long(num);
    return *this;
}

// Арифметические операторы
Long Long::operator+(const Long& other) const {
    if (sign == other.sign) {
        Long result = addAbsolute(other);
        result.sign = sign;
        return result;
    }

    int cmp = compareAbsolute(other);
    if (cmp == 0) return Long(0);

    Long result;
    if (cmp > 0) {
        result = subtractAbsolute(other);
        result.sign = sign;
    }
    else {
        result = other.subtractAbsolute(*this);
        result.sign = other.sign;
    }

    result.normalize();
    return result;
}

Long Long::operator-(const Long& other) const {
    return *this + (-other);
}

Long Long::operator*(const Long& other) const {
    Long result;
    result.digits.resize(digits.size() + other.digits.size(), 0);

    for (size_t i = 0; i < digits.size(); ++i) {
        int carry = 0;
        for (size_t j = 0; j < other.digits.size() || carry; ++j) {
            long long current = result.digits[i + j] +
                digits[i] * (j < other.digits.size() ? other.digits[j] : 0) +
                carry;
            result.digits[i + j] = current % 10;
            carry = current / 10;
        }
    }

    result.sign = (sign != other.sign);
    result.normalize();
    return result;
}

Long Long::operator/(const Long& other) const {
    if (other.isZero()) {
        throw std::runtime_error("Division by zero");
    }

    Long dividend = this->abs();
    Long divisor = other.abs();

    if (dividend < divisor) {
        return Long(0);
    }

    Long result, current;
    result.digits.resize(dividend.digits.size(), 0);

    for (int i = dividend.digits.size() - 1; i >= 0; --i) {
        current.digits.insert(current.digits.begin(), dividend.digits[i]);
        current.normalize();

        int x = 0;
        int left = 0, right = 10;
        while (left <= right) {
            int mid = (left + right) / 2;
            Long product = divisor * Long(mid);
            if (product <= current) {
                x = mid;
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        result.digits[i] = x;
        current = current - divisor * Long(x);
    }

    result.sign = (sign != other.sign);
    result.normalize();
    return result;
}

Long Long::operator%(const Long& other) const {
    if (other.isZero()) {
        throw std::runtime_error("Division by zero");
    }

    Long quotient = *this / other;
    Long remainder = *this - quotient * other;
    return remainder;
}

// Унарные операторы
Long Long::operator-() const {
    Long result = *this;
    if (!isZero()) {
        result.sign = !sign;
    }
    return result;
}

Long Long::operator+() const {
    return *this;
}

// Составные операторы присваивания
Long& Long::operator+=(const Long& other) {
    *this = *this + other;
    return *this;
}

Long& Long::operator-=(const Long& other) {
    *this = *this - other;
    return *this;
}

Long& Long::operator*=(const Long& other) {
    *this = *this * other;
    return *this;
}

Long& Long::operator/=(const Long& other) {
    *this = *this / other;
    return *this;
}

Long& Long::operator%=(const Long& other) {
    *this = *this % other;
    return *this;
}

// Операторы инкремента и декремента
Long& Long::operator++() {
    *this += Long(1);
    return *this;
}

Long Long::operator++(int) {
    Long temp = *this;
    ++(*this);
    return temp;
}

Long& Long::operator--() {
    *this -= Long(1);
    return *this;
}

Long Long::operator--(int) {
    Long temp = *this;
    --(*this);
    return temp;
}

// Операторы сравнения
bool Long::operator==(const Long& other) const {
    return sign == other.sign && digits == other.digits;
}

bool Long::operator!=(const Long& other) const {
    return !(*this == other);
}

bool Long::operator<(const Long& other) const {
    if (sign != other.sign) {
        return sign; // если this отрицательный, а other положительный
    }

    if (sign) { // оба отрицательные
        return compareAbsolute(other) > 0;
    }
    else { // оба положительные
        return compareAbsolute(other) < 0;
    }
}

bool Long::operator<=(const Long& other) const {
    return *this < other || *this == other;
}

bool Long::operator>(const Long& other) const {
    return !(*this <= other);
}

bool Long::operator>=(const Long& other) const {
    return !(*this < other);
}

// Ввод/вывод
std::ostream& operator<<(std::ostream& os, const Long& num) {
    if (num.sign && !num.isZero()) {
        os << '-';
    }

    for (int i = num.digits.size() - 1; i >= 0; --i) {
        os << static_cast<char>(num.digits[i] + '0');
    }
    return os;
}

std::istream& operator>>(std::istream& is, Long& num) {
    std::string str;
    is >> str;
    num = Long(str);
    return is;
}

// Вспомогательные методы
std::string Long::toString() const {
    std::string result;
    if (sign && !isZero()) {
        result += '-';
    }

    for (int i = digits.size() - 1; i >= 0; --i) {
        result += static_cast<char>(digits[i] + '0');
    }
    return result;
}

bool Long::isZero() const {
    return digits.size() == 1 && digits[0] == 0;
}

Long Long::abs() const {
    Long result = *this;
    result.sign = false;
    return result;
}

// Пример использования
int main() {
    try {
        Long a("12345678901234567890");
        Long b("98765432109876543210");

        std::cout << "a = " << a << std::endl;
        std::cout << "b = " << b << std::endl;
        std::cout << "a + b = " << a + b << std::endl;
        std::cout << "a - b = " << a - b << std::endl;
        std::cout << "a * b = " << a * b << std::endl;
        std::cout << "b / a = " << b / a << std::endl;
        std::cout << "b % a = " << b % a << std::endl;

        Long c = -a;
        std::cout << "-a = " << c << std::endl;
        std::cout << "a == b: " << (a == b) << std::endl;
        std::cout << "a < b: " << (a < b) << std::endl;

        // Тестирование инкремента
        Long d("999");
        std::cout << "d = " << d << std::endl;
        std::cout << "++d = " << ++d << std::endl;
        std::cout << "d++ = " << d++ << std::endl;
        std::cout << "d = " << d << std::endl;

    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
